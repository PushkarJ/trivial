require 'rspec'
require_relative '../../models/vulnerability'

RSpec.describe Vulnerability, "#severity" do

  def vuln_data(attrs = {})
    data = {
      severity: "LOW",
      score1: 1.2,
      score2: 9.2,
      vulnerability_id: "CVE-2020-3810",
      description: "some description",
      url: "http://example.org/cve-2020-3810",
      package_name: "curl",
      title: "Bad stuff is afoot",
      installed_version: "1.0",
      "fixed_version": "1.0.1"
    }.merge(attrs)
    hash = {
      "VulnerabilityID" => data[:vulnerability_id],
      "InstalledVersion" => data[:installed_version],
      "FixedVersion" => data[:fixed_version],
      "Severity" => data[:severity],
      "Description" => data[:description],
      "PrimaryURL" => data[:url],
      "PkgName" => data[:package_name],
      "Title" => data[:title],
      "CVSS" => {
        "nvd" => {
          "V3Score" => data[:score1]
        },
        "redhat" => {
          "V3Score" => data[:score2]
        }
      }
    }
    if data[:fixed_version] == ""
      hash.delete("FixedVersion")
    end
    hash
  end

  it "returns installed version" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(installed_version: "1", fixed_version: "2"))
    expect(vuln.installed_version).to eq("1")
  end

  it "returns fixed version" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(fixed_version: "2"))
    expect(vuln.fixed_version).to eq("2")
  end

  it "returns '' if fixed version is not present" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(fixed_version: ""))
    expect(vuln.fixed_version).to eq("")
  end

  it "returns downcased Severity" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(severity: "FOO"))
    expect(vuln.severity).to eq("foo")
  end

  it "returns image string" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data())
    expect(vuln.image).to eq("path:tag")
  end

  it "returns target" do
    vuln = Vulnerability.new("path", "tag", "registry.example.org/cool-image:v1.2.3 (debian 10.5)", vuln_data())
    expect(vuln.target).to eq("registry.example.org/cool-image:v1.2.3 (debian 10.5)")
  end

  it "returns (max V3Score) for score" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(score1: 9.9, score2: 1.2))
    expect(vuln.score).to eq(9.9)
  end

  it "returns CVE ID" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(vulnerability_id: "123"))
    expect(vuln.vulnerability_id).to eq("123")
  end

  it "returns description" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(description: "some desc"))
    expect(vuln.description).to eq("some desc")
  end

  it "returns url" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(url: "some-url"))
    expect(vuln.url).to eq("some-url")
  end

  it "returns title" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(title: "some-title"))
    expect(vuln.title).to eq("some-title")
  end

  it "returns package_name" do
    vuln = Vulnerability.new("path", "tag", "target", vuln_data(package_name: "some-package-name"))
    expect(vuln.package_name).to eq("some-package-name")
  end

  it "returns distro if exists as part of the target" do
    vuln = Vulnerability.new("path", "tag",
                             "projects-stg.registry.vmware.com/tkg/azure-cloud-controller-manager:v0.5.1_vmware.2 (debian 9.8)",
                             vuln_data(package_name: "some-package-name"))
    expect(vuln.distro).to eq("debian 9.8")
  end

  it "returns blank for distro if it does not exist as part of the target" do
    vuln = Vulnerability.new("path", "tag",
                             "Pipfile.lock",
                             vuln_data(package_name: "some-package-name"))
    expect(vuln.distro).to eq("")
  end
end
